#접근 제어
# 클래스 인터페이스를 설계할 때, 클래스를 외부에 어느 정도까지 노출할지 결정하는 것은 중요한 일읻.
# 클래스에 너무 깊이 접근하도록 허용하며느 애플리케이션에서 각 요소 간의 결합도가 높아질 우려가 있다.
# 다시 말해 이 클래스의 사용자 코드는 클래스 내부 구현의 세세한 부부분에까지 종속적이 되지 쉽다는 것이다.

# 루비에서는 객체 상태를 변경하는 방법은 메소드를 호출하는 것 뿐이다. 메소드에 대한 접근을 적적히 설정하면
# 객체에 접근을 제저할 수 있는 셈이다. 객체의 상태를 망가뜨릴 수 있는 메소드는 노출해서는 안된다.

# 루비에는 3가지 보호 단계가 있다.

# public 메소드는 누구나 호출할 수 있다. 아무런 접근제어를 하지 않는다.
# 루비에서는 private인 initialize를 제외한 메소드는 기본적으로 public이다.

# protected 메소는 그 객체를 정의한 클래스와 하위 클래스에서만 호출할 수 있다.
# 접근이 가게도 상으로 제한 되는 것이다.

# private 메소드는 수신자를 지정해서 호출할 수 없다.
# 이 메소드의 수신자는 항상 self이기 때문이다.
# private 메소드는 오직 현재 객체의 문맥 하에서만 호출할 수 있다.
# 다른 객체의 private 메소드는 접근할 수 없다.

# 루비와 다른 객체 지향언어의 중요한 차이점은 접근제어가 동적으로 결졍된다는 것이다.
# 즉 정적이 아니라 프로그램이 실행될 때 결정된다. 따라서 접근 위반 예외는 제한된 메소드를
# 실제로 호출한 그 순간에만 발생하게 된다.

#접근 제어 기술하기
# 클래스나 모듈을 정의할 때 public, protected, private 함수를 사용해서 접근제어를 기술할 때
# 방법은 크게 두 가지가 있다.

# 아무 인자 없이 함수를 사용한다면, 이 3가지 함수 다음에 오는 메소드의 기본 접근 제한 단계를 정한다.
class MyClass

  def method1 #기본 값은 'public'이다.
    #...
  end

  protected #이제부터 선언하는 모든 메소드는 'protected'가 된다.
   def method2 #'protected'가 된다.
     #...
   end

  private #이제부터 선언하는 메소드는 모두 'private'이 된다.
    def method3 #'private'이 된다.
      #...
    end

  public #이제부터 선언하는 모든 메소드는 'public'이 된다.
    def method4 #'public'이 된다.
        #...
    end
end

# 다른 방법으로는 접근 제어 함수 뒤에 인자로 메소드 이름을 써 주는 방법이 있다.
# 이미 정의된 메소드의 접근 단계도 다시 정의할 수 있다.
class MyClass2
  def method1
  end
  def method2
  end
  def method3
  end
  def method4
  end

  public :method1, :method4
  protected :method2
  private :method3

end
