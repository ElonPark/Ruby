# 실제로 사용되는 대부분의 프로그램은 데이터 컬렉션을 처리한다.
# 루비에는 컬렉션을 다루기 위한 배열과 해시라는 두개의 내장 클래스가 준비되어 있다.
# 이 두 클래스에 익숙해지는 것이 실력 있는 루비 프로그래머가 되는 지름길이다.
# 두 클래스는 매우 다양한다 기능을 제공하므로 이를 전부 익히는 데는 상당한 시간을 필요로 한다.
# 	하지만 루비에서 컬렉션을 다루기 위한 클래스가 배열과 해시만 있는 것이 아니다.
#   루비에는 코드 덩어리를 캡슐화할 수 있도록 도와주는 블록이는 문법이 있다.
#   블록과 컬레션을 함께 사용하면 강력한 반복자 구문이 된다.

#배열
# Array클래스는 객체 참조를 컬렉션으로 저장한다. 각 객체의 참조는 배열에서 하나의 위치를 차지하며 이 위치는 음이 아닌 정수로 표현된다.
# 배열을 만들때는 이터럴을 사용하거나 명시적으로 Array 객체를 생성할 수 있다. 배열 리터럴을 이용할 때는 간단히 대괄호 사이에 포함하고자
# 하는 객체를 나열하면 된다.
a = [3.14159, "pie", 99]
p a.class
p a.length
p a[0]
# p a + 2
p a[1]
p a[2]
p a[3]

puts "\n Array B"
b = Array.new
p b.class
p b.length
p b[0] = "sencond"
p b[1] = "array"
p b

# 배열의 [] 연산자를 이용하면 위치를 지정할 수 있다. Array 클래스의 인스턴스 메소드 이므로 하위 클래스에서 재정의 할 수 있다.
# 배열의 인덱스는 0부터 시작한다. 배열의 위치를 음이 아닌 정수로 지정하면 해당 위치의 객체를 반환하고 그 위치에 아무것도 없다면
# nil을 반환한다.
a = [1,3,5,7,9]
p a[-1]
p a[-2]
p a[-99]

# 배열 인덱스를 [start, count]처럼 숫자 쌍으로 지정할 수도 있다. 이것은 시작점(start)에서 count만큼의 객체 함조를 뽑아서
# 새로운 배열을 만들어 반환한다.
p a[1, 3]
p a[3, 1]
p a[-3, 2]
# 마지막 인덱스는 범위를 사용할 수도 있는데, 시작 위치와 끝 위치를 점 두개 또는 세 개로 구분해서 적어주면 된다.
# 점 두 개를 사용하는 형식은 마지막 경계값을 포함하고, 세 개를 사용하는 형식에서는 포함하지 않는다.
p a[1..3]
p a[1...3]
p a[3..3]
p a[-3..-1]

# []연산자에 대응하는 []= 연산자도 있다. 이 연사낮를 이용해 배열의 특정 위치에 값을 대입할 수 있다. 하나의 정수 인덱스를 사용할 때는
# 그 위치의 요소가 대입문의 오른쪽 편에 있는 값으로 바뀐다. 그리고 인덱스 사이에 간격이 생기면 이 사이의 값은 nil로 채워진다.
a = [1,3,5,7,9]
a[1] = 'bat'
a[-3] = 'cat'
a[3] = [9, 8]
a[6] = 99
p a

# []= 연산제에 쓰인 인덱스가 두개(시작 위치롸 길이)가 범위라면, 원래 배열의 해당하는 위치에 있는 원소들이 대입문의 오른쪽 편에 있는 값(어떤 형식이든 무방)으로
# 바뀐다. 길이가 0이라면 오른쪽의 값이 시작 위치 바로 앞에 삽입될 것이다. 대입문 오른편에도 배열이 오면 이 배열의 원소를 이용해 값을 바꿀 것이다.
# 왼편에서 선택된 요소의 오른편에서 지정된 원소의 수가 다른 경우에도 배열 크기는 자동으로 조절된다.
 a = [1,3,5,7,9]
a[2, 2] = 'cat'
a[2, 0] = 'dog'
a[1, 1] = [9, 8, 7]
a[0..3] = []
a[5..6] = 99, 98
p a

# 이 외에도 배열에는 유용한 메소드가 많다. 이를 활용하여 스택, 집합, 큐, 양방향 큐, FIFO 큐로 배열을 다룰수 있다.
# 예를 들어 push와 pop을 사용하면 배열의 맨 뒤에 요소를 추가하거나, 맨 뒤의 요소를 제거할 수 있다.
# 이를 통해 배열을 스택으로 사용할 수 있다.
stack = []
stack.push "red"
stack.push "green"
stack.push "blue"
p stack

# 비슷하게 unshift와 shift를 사용하면 배열 맨 앞의 요소를 추가하거나 삭제할 수 있다.
# shift와 push를 조합하면 배열을 선입선출(FIFO)큐로 사용할 수 있다.
queue = []
queue.push "red"
queue.push "green"
p queue
p queue.shift
p queue.shift

# fast와 last 메소드는 배열의 맨 앞이나 맨 뒤에서 n개의 요소들을 반환한다.
# 이때 앞선 메소드들과 달리 배열의 요소를 삭제하지 않는다.
array = [1,2,3,4,5,6,7]
p array.first(4)
p array.last(4)

puts "======\n\n해시\n"
 #해시
 # 해시는 객체 참조가 색인된 컬렉션이라는 점에서 배열과 비슷하다.
 # 하지만 배열은 정수를 인덱스로 사용하는 반면에, 해시의 인덱스로는 심범, 문자열, 정규 표헌식,
 # 심지어는 어떤 객체라도 사용할 수 있다.
 # 따라서 해시에 하나의 값을 저장하고자 할 때 두 개의 객체가 필요하다.
h = { 'dog' => 'canine', 'cat' => 'feline', 'donkey' => 'asinine' }
p h
p h.length
p h['dog']
h['cow'] = 'bovine'
h[12] = 'dodecine'
h['cat'] = 99
p h

# 키가 심벌일때 한해서 새로운 축약 표현을 사용하 수 있다.
h = { :dog => 'canine', :cat => 'feline', :donkey => 'asinine' }
p h
# 위와 같이 키가 심별일 경우에 한해 심벌 앞의 콜론을 지우고 =>를 콜론으로 대체해 다음과 같이 사용할 수 있다.
h = { dog: 'canine', cat: 'feline', donkey: 'asinine' }
p h
# 해시는 인덱스로 어떤 객체라도 사용할 수 있다.
# 루비는 해시에 요소를 추가한 순서를 기억한다. 따라서 해시를 반복할 때 루비는 요소를 추가한 순서대로 반복한다.
